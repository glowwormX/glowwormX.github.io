---
layout: post
title:  redis开发与运维
date:   2019-11-13 08:00:00 +0800
categories: 
tag: 
- 数据库
---

* content
{:toc}

# 5种数据结构

5种数据结构及存储   
![](/styles/images/other/redis1.png)
5种数据结构对应编码   

![](/styles/images/other/redis2.png)
## 1.字符串String (也可以存为int)

### 常用命令   

![](/styles/images/other/redis3.png)

### 编码

* int： 8个字节的长整型。
* embstr： 小于等于39个字节的字符串。
* raw： 大于39个字节的字符串。

### 使用场景

1. 缓存功能
2. 计数
3. 共享Session
4. 限速
```
//一分钟不能访问5次
isExists = redis.set(key,1,"EX 60","NX");
if(isExists != null || redis.incr(key) <=5){
// 通过
}else{
// 限速
}
```
5. 分布式锁
```
//网上的例子 感觉有bug
//加锁 5秒后超时 value可以自定义设置
int timeout = 5;
lock = null;
while (lock == null) {
    time = System.currentTimeMillis();
    expireTime = time + timeout * 1000;
    lock = redis.set(key, expireTime, "NX");
    //两种情况key上无锁 或者 key上的锁过期了
    if (lock != null || redis.get(key) < time && redis.getset(key, expireTime) < time) {
        //redis.get(key) < time 两个线程到这里再 redis.getset(key, expireTime) < time，只有一个通过，但是会把锁时间延长
        break;
    } esle {
        sleep(1);
    }   
}
doSomething();

time = System.currentTimeMillis();
if (time < expireTime) {
    redis.del(key);
}

```

```
//加锁 5秒后超时 value可以自定义设置
time = System.currentTimeMillis();
while(redis.set(key,time,"EX 5","NX") == null) {
    sleep(1);
}

doSomething();

//TODO get del要原子操作
if (time == redis.get(key)) {
    redis.del(k);
}
```

## 2.哈希 hash

### 常用命令   

![](/styles/images/other/redis4.png)

### 编码

哈希类型的内部编码有两种：
* ziplist（压缩列表） ： 当哈希类型元素个数小于hash-max-ziplist-entries
配置（默认512个） 、 同时所有值都小于hash-max-ziplist-value配置（默认64
字节） 时， Redis会使用ziplist作为哈希的内部实现， ziplist使用更加紧凑的
结构实现多个元素的连续存储， 所以在节省内存方面比hashtable更加优秀。

* hashtable（哈希表） ： 当哈希类型无法满足ziplist的条件时， Redis会使
用hashtable作为哈希的内部实现， 因为此时ziplist的读写效率会下降， 而
hashtable的读写时间复杂度为O（1） 。

### 使用场景

ORM映射，表名+id为key，字段名为field，值为vule


## 3 列表 list

### 常用命令   

![](/styles/images/other/redis5.png)

![](/styles/images/other/redis6.png)

### 编码

·ziplist（压缩列表） ： 当列表的元素个数小于list-max-ziplist-entries配置
（默认512个） ， 同时列表中每个元素的值都小于list-max-ziplist-value配置时
（默认64字节） ， Redis会选用ziplist来作为列表的内部实现来减少内存的使
用。
·linkedlist（链表） ： 当列表类型无法满足ziplist的条件时， Redis会使用
linkedlist作为列表的内部实现。

### 使用场景
1.消息队列   
2.文章列表(list+hash，hash存具体内容，list key：userId value 文章id[+name])   

·lpush+lpop=Stack（ 栈）   
·lpush+rpop=Queue（ 队列）   
·lpsh+ltrim=Capped Collection（ 有限集合）   
·lpush+brpop=Message Queue（ 消息队列）   


## 4 集合set

### 常用命令   
![](/styles/images/other/redis7.png)
scard：计算个数   
sismember：是否存在   
srandmember：随机返回指定个数   
spop：随机弹出一个（随机删除一个，返回删除的）   
inter：交集      
uinon：并集       
diff：差集(res=key1-key2-key3)      

### 编码

·intset（整数集合） ： 当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个） 时， Redis会选用intset来作为集合的内部实
现， 从而减少内存的使用。
·hashtable（哈希表） ： 当集合类型无法满足intset的条件时， Redis会使
用hashtable作为集合的内部实现。

### 使用场景
主要特征是交集并集差集上
1. 标签
2. 复杂查询
如要经常访问销量大于1w的商品，(0,1w] (1w,2w] (2w,*] 3个key存了这三个区间的Id，那么大于1w的就可以使用并集

## 5 有序分数集合zset
![](/styles/images/other/redis9.png)

### 常用命令   
![](/styles/images/other/redis8.png)
zrank：返回排名   
zincrby：增加该成员的分数   
zrange：返回开始到结束的成员 withscores会返回分数   
zrangebyscore： 返回分数开始到结束的成员   
```
127.0.0.1:6379> zrangebyscore user:ranking (200 +inf withscores
1) "tim"
2) "220"
3) "martin"
4) "250"
5) "tom"
6) "260
``` 

### 编码

·ziplist（压缩列表） ： 当有序集合的元素个数小于zset-max-ziplistentries配置（默认128个） ， 同时每个元素的值都小于zset-max-ziplist-value配
置（默认64字节） 时， Redis会用ziplist来作为有序集合的内部实现， ziplist
可以有效减少内存的使用。
·skiplist（跳跃表） ： 当ziplist条件不满足时， 有序集合会使用skiplist作
为内部实现， 因为此时ziplist的读写效率会下降。

### 使用场景

排行榜,分数为时间、按照播放数量、按照获得的赞数


# 持久化

## RDB

### 触发机制
1. 手动触发    
save（阻塞主线程直至备份完成，不推荐）   
bgsave（阻塞主线程，直至fork出一个进程，新线程进行备份）   
2. 自动触发   
1） 使用save相关配置， 如“save m n”。 表示m秒内数据集存在n次修改时， 自动触发bgsave。   
2） 如果从节点执行全量复制操作， 主节点自动执行bgsave生成RDB文件并发送给从节点， 更多细节见6.3节介绍的复制原理。   
3） 执行debug reload命令重新加载Redis时， 也会自动触发save操作。   
4） 默认情况下执行shutdown命令时， 如果没有开启AOF持久化功能则自动执行bgsave。   

### bgsave流程
![](/styles/images/other/redis11.png)

1） 执行bgsave命令， Redis父进程判断当前是否存在正在执行的子进程， 如RDB/AOF子进程， 如果存在bgsave命令直接返回。   
2） 父进程执行fork操作创建子进程， fork操作过程中父进程会阻塞， 通过info stats命令查看latest_fork_usec选项， 可以获取最近一个fork操作的耗时， 单位为微秒。   
3） 父进程fork完成后， bgsave命令返回`“Background saving started”`信息并不再阻塞父进程， 可以继续响应其他命令。   
4） 子进程创建RDB文件， 根据父进程内存生成临时快照文件， 完成后对原有文件进行原子替换。 执行lastsave命令可以获取最后一次生成RDB的时间， 对应info统计的rdb_last_save_time选项。   
5） 进程发送信号给父进程表示完成， 父进程更新统计信息， 具体见info Persistence下的rdb_*相关选项。   

### RDB文件的处理
运行期动态执行（get回去对应值）   
`config set dir {newDir}` 保存路径   
`config set dbfilename {newFileName}` 保存文件    
`config set rdbcompression {yes|no}` 压缩   

### RDB的优缺点
1. RDB的优点：   
·RDB是一个紧凑压缩的二进制文件， 代表Redis在某个时间点上的数据快照。 非常适用于备份， 全量复制等场景。    
比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs） ， 用于灾难恢复。   
·Redis加载RDB恢复数据远远快于AOF的方式。   
2. RDB的缺点：   
·RDB方式数据没办法做到实时持久化/秒级持久化。 因为bgsave每次运行都要执行fork操作创建子进程， 属于重量级操作， 频繁执行成本过高。   
·RDB文件使用特定二进制格式保存， Redis版本演进过程中有多个格式的RDB版本， 存在老版本Redis服务无法兼容新版RDB格式的问题   

## AOF （append only file）
### AOF流程
redis.conf中配置文件：
appendonly no
appendfilename "appendonly.aof"

![](/styles/images/other/redis12.png)

1. 所有的写入命令会追加到aof_buf(缓冲区)中，使用文本协议格式。
``
set hello word：
*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n
``   
2. AOF缓冲区根据对应的策略向硬盘做同步操作。   

    配置文件中 appendfsync 参数:   
    always 每次写入aof_buf后系统调用fsync（tps差）   
    everysec 每次写入aof_buf后系统调用write，fsync使用另外线程调用，如一秒一次(推荐)   
    no 每次写入aof_buf后系统调用write，由操作系统自己决定fsync(通常最长30s)   
3. 随着AOF文件越来越大， 需要定期对AOF文件进行重写， 达到压缩的目的(删除无效命令，合并多条命令等)。   

    手动触发 bgrewriteaof   
    自动触发，参数控制：   
    auto-aof-rewrite-percentage 100 （当前AOF文件空间(aof_current_size)和上一次重写后AOF文件空间(aof_base_size)的比值)   
    auto-aof-rewrite-min-size 64mb （运行AOF重写时文件最小体积）   
    自动触发时机 = aof_current_size > auto-aof-rewrite-minsize && (aof_current_size-aof_base_size) / aof_base_size >= auto-aof-rewrite-percentage   
    
    ![](/styles/images/other/redis13.png)   
    3.1和3.2中fork出来新进程后或同时写在两个buf，一份会同步到旧文件，一份同步到新文件，最后新替换旧   

4. 当Redis服务器重启时， 可以加载AOF文件进行数据恢复。   

    ![](/styles/images/other/redis14.png)   
    
# 架构

## 数据同步原理
过程：   
![](/styles/images/other/redis15.png)   

(2) 从节点会建立一个socket套接字， 专门用于接受主节点发送的复制命令，   
如果从节点无法建立连接， 定时任务会无限重试直到连接成功或者执行slaveof no one取消复制   
(3) 发送ping命令，如果发送ping命令后， 从节点没有收到主节点的pong回复或者超时， 比如网络超时或者主节点正在阻塞无法响应命令， 从节点会断开复制连接， 下次定时任务会发起重连   
(5) 同步数据集，首次会全量同步，命令有sync和psync(>=2.8)，psync可以从某个节点开始同步

psync {runId} {offset}   返回：FULLRESYNC CONTINUE ERR

### 全量复制

![](/styles/images/other/redis16.png)   

### 部分复制

![](/styles/images/other/redis17.png)   

## 主从
三种创建方式：
1. 在配置文件中加入slaveof {masterHost} {masterPort} 随Redis启动生效。
2. 在redis-server启动命令后加入--slaveof {masterHost} {masterPort}生效。
3. 直接使用命令： slaveof {masterHost} {masterPort}生效（也可切换至另一个主节点，会清空之前节点数据）。

断开主从： slaveof no one
从节点只读： slave-read-only yes

是否往从节点立即发送： repl-disable-tcp-nodelay no （yes会默认将40ms的内容一起发送）

拓扑：一主一从 一主多从 树状主从(从节点再发给其他从节点)

## 哨兵

## 集群
