## 椭圆曲线：   
K = kG，K、G为椭圆曲线上的点，k为小于n的整数(n为G的阶,nG=O∞ )      
2G的计算方式为 G做切线到对面椭圆曲线上的交点，取x对称点为2G   
3G的计算方式为 2G与G连接的线与椭圆曲线交点，去x对称点为3G   
因此已知k、G求K容易，已知K，G求k难(非对称的精髓)   




    1.Alice选定一条椭圆曲线E，并取椭圆曲线上一点作为基点G 假设选定E29(4,20)，基点G(13,23) , 基点G的阶数n=37

    2.Alice选择一个私有密钥k（k<n），并生成公开密钥K=kG 比如25, K= kG = 25G = (14,6）

    3.Alice将E和点K、G传给Bob

    4.Bob收到信息后，将待传输的明文编码到上的一点M（编码方法略），并产生一个随机整数r（r<n,n为G的阶数） 假设r=6 要加密的信息为3,因为M也要在E29(4,20) 所以M=(3,28)

    5.Bob计算点C1=M+rK和C2=rG C1= M+6K= M+6*25*G=M+2G=(3,28)+(27,27)=(6,12) C2=6G=(5,7)

    6.Bob将C1、C2传给Alice

    7.Alice收到信息后，计算C1-kC2，结果就应该是点M C1-kC2 =(6,12)-25C2 =(6,12)-25*6G =(6,12)-2G =(6,12)-(27,27) =(6,12)+(27,2) =(3,28)

数学原来上能解密是因为:C1-kC2=M+rK-krG=M+rkG-krG=M（K = kG）


## RSA
两个素数相乘得到的积容易，已知一个数，因式分解难
```java
    随意选择两个大的质数p和q，p不等于q，计算N=pq。//3233=61*53
    根据欧拉函数，求得r = (p-1)(q-1) //r=60*52=3120
    选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质）。//随机数17,17*2753 mod 3120=1   
    将 p 和 q 的记录销毁。公钥(n,e),私钥(n,d) //(3233,17),(3233,2753)
    
    将 65 加密
    密文为：65^17 mod 3233 = 2790
    解密:2790^2753 mod 3233 = 65 (为什么？各种定理才能证明)
```
