---
layout: post
title:  数据库理论
date:   2019-09-27 08:00:00 +0800
categories: 基础
tag: 数据库
---

# 事务隔离级别 

* 脏读：更新还未提交，其他事务能读到更新后的
* 不可重复读：事物里对一条数据读两次，读到不一样的（修改）
* 幻读：事物里对结果集读两次，读到不一样的（新增和删除）


* READ_UNCOMMITTED   有脏读 不可重复读 幻读
* READ_COMMITTED   解决脏读 有不可重复读 幻读 (大多数默认 MyISAM)
* REPEATABLE_READ   解决不可重复读 有幻读 （InnoDB默认，可以用Next-Key Lock解决幻读）
* SERIALIZABLE   并发差

# 索引
* 覆盖索引
优先从辅助索引里找，数据量小(叶子只有id)，如 `select id/count(*) from table where other_index = xxx;`

* 不使用索引的情况，
除了一般说的is null, !=, like %xxx，外   
使用辅助索引查时，若查询结果为id外的且结果占整张表过大（一般20%）的会全表扫描    
因为使用辅助索引查到id后，要将这些id去聚集索引里找，这时为随机读，磁盘随机读一般较慢(固态会高一些)，mysql优化器会选择全表扫(顺序读)

* Index Hint(索引提示)
use/force/ignore index等

* Multi-Range Read (MRR)   
为了减少随机访问 （Explain中Extra字段显示 Using MRR）
* Index Collection Pushdown   
在存储引擎层就对数据进行过滤，减少sql层对数据的读取  （Explain中Extra字段显示 Using Index Condition）

[MySQL EXPLAIN详解](https://www.jianshu.com/p/ea3fc71fdc45)

# 锁
* S锁 共享锁（读锁） select ... lock in share mode;   
* X锁 排他锁（写锁） select ... for update;   
* IS IX 意向锁   
若对某一行加X锁，那么首先对对应数据库、表加IX锁，那么后面的想对表再加X/S，表上有IX锁，说明本表或行上有X锁在，就不要遍历每一行了

    | |IS|IX|S|X|
    |:---:|:---:|:---:|:---:|:---:|
    |IS|兼容|兼容|兼容|不兼容|
    |IX|兼容|兼容|不兼容|不兼容|
    |S|兼容|不兼容|兼容|不兼容|
    |X|不兼容|不兼容|不兼容|不兼容|

## 行锁算法   
Record Lock     单个行记录的锁（READ_COMMITTED级别默认）   
Gap Lock        间隙锁，锁一个区间，不包含边界   
Next-Key Lock   锁一个区间，包含边界（REPEATABLE_READ级别默认）   

在主键上查询 `select * from table where id = 1;`会聚集索引上加Record Lock
在辅助索引上查询 `select * from table where test_index = 1;`会在聚集索引上加Record Lock，辅助索引上加Next-Key Lock，
若test_index数据有(0,1,3)，区间为不包含边界的上下两个值(0,3)，所有在两个值时间再做插入(2)会阻塞

## 死锁发生例子
1. 两个事务先获取S锁，再进行写操作，X锁

    T1|T2
    |:---:|:---:|
    |获取a表S锁          | 
    |                   | 获取a表S锁
    |修改数据  X锁（阻塞）   | 
    |                   | 修改数据 X锁（死锁抛异常，rollback）
    |修改成功   | 

2. 某个事务需要同时得到两个锁   

    T1|T2
    |:---:|:---:|
    |获取行a X锁          | 
    |                   | 获取行b X锁
    |获取行b X锁（阻塞）   | 
    |                   | 获取行a X锁 （死锁抛异常，rollback）
    |获取两个锁 查询成功   | 

3. X 和 范围S锁

    T1|T2
    |:---:|:---:|
    |select * from company_file where id = 2 for update;          | 
    |                   | select * from company_file where id < 20 lock in share mode;(阻塞，占了(*,2)的锁)
    |insert into company_file select 0; （死锁抛异常，rollback）  | 
    |                   | 查询成功 
   
    T1|T2
    |:---:|:---:|
    |select * from company_file where id = 2 for update;          | 
    |                   | select * from company_file where id < 20 lock in share mode;(阻塞，占了(*,2)的锁)
    |insert into company_file select 19; （正常）  | 
    |insert into company_file select 0; （死锁，但正常提交，检测到了死锁，undo量大，将T2回滚）  | 
    |                   | 死锁抛异常，rollback 
  
    T1|T2
    |:---:|:---:|
    |select * from company_file where id = 2 for update;          | 
    |insert into company_file select 0; （正常）  | 
    |                   | select * from company_file where id < 20 lock in share mode;(阻塞，占了(*,0)的锁)
    |insert into company_file select 1; （正常）  | 
    |insert into company_file select -1; （死锁，但正常提交）  | 
    |                   | 死锁抛异常，rollback 

死锁检测，wait-for graph，将等待的事务画图，若T1等T2，则画T1->T2，若同时T2->T1，成环，则回滚undo量最小的事务

## 锁升级
innodb 根据页进行加锁，资源(内存)开销小，不会进行锁升级   
若表有3 000 000数据页，每页100条数据   
若在数据上加锁，每个锁10字节，内存3G（sqlServer，升级为表锁）   
页上加锁，每个30字节，90M   