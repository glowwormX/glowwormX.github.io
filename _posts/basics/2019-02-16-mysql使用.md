---
layout: post
title:  mysql使用
date:   2019-02-16 08:00:00 +0800
categories: 基础
tag: 数据库
---

## 安装使用
* linux安装mysql   
https://blog.csdn.net/qq_15783243/article/details/78565705   
https://www.cnblogs.com/xinjing-jingxin/p/8025805.html   

* .scripts出错
yum -y install numactl

* 找不到/tmp/mysql.sockm、mariadb.log错误
vi /etc/my/cnf   
修改   
socket=/tmp/mysql.sock   
log-error=/var/log/mariadb/mariadb.log   
pid-file=/var/run/mariadb/mariadb.pid   


* root用户登录名为mysql的数据库  
./mysql -u root mysql -p   

* 创建用户user1密码123456，且可以外部链接   
grant all on *.* to user1 identified by '123456';    


## 基本操作  
https://www.cnblogs.com/fly1988happy/archive/2011/12/15/2288554.html

* 查看表的存储引擎   
1 查看table_name `show create table table_name;`
2 查看MyDB的所有表引擎 

        select table_catalog
              ,table_schema
              ,table_name
              ,engine
        from information_schema.tables
        where table_schema='MyDB';
        //and engine='MyISAM';
        
## 优化

* 前缀索引，前几位区分度高使用前几位即可，减小存储    
    给表email字段前六位添加索引`alter table SUser add index index2(email(6));`   
    分析区分度 可以用5%标准
    ```
    select 
      count(distinct left(email,4)）as L4,
      count(distinct left(email,5)）as L5,
      count(distinct left(email,6)）as L6,
      count(distinct left(email,7)）as L7,
    from SUser;
    ```

* 身份证，后缀的区分度高   
    1反转存储   
    `select field_list from t where id_card = reverse('input_id_card_string');`   
    2hash存储   
    `alter table t add id_card_crc int unsigned, add index(id_card_crc);`   
    `select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'`
    
    首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。
    
    它们的区别，主要体现在以下三个方面：
    
    从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。
    
    在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。
    
    从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。
    
    [参考MySQL实战45讲/11讲]()

* order by是如何工作的   
    `select city,name,age from t where city='杭州' order by name limit 1000;`   

无覆盖索引，有city索引   
    
1. 初始化sort_buffer，确定放入name、city、age这三个字段；
1. 从索引city找到第一个满足`city='杭州'`条件的主键id；
1. 到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；
1. 从索引city取下一个记录的主键id；
1. 重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；
1. 对sort_buffer中的数据按照字段name做快速排序；
1. 按照排序结果取前1000行返回给客户端。

相关参数 sort_buffer_size 排序内存最大值  max_length_for_sort_data 排序每行最大值   
若行数过多，超过了sort_buffer_size，会利用磁盘临时文件辅助排序，先排好一部分放入磁盘归并排序   
若列数过长，超过了max_length_for_sort_data，第一步只取出name id字段，排序好后第七步再检索一遍聚集索引   

可以覆盖索引的情况下： 有复合索引(city,name) 或者(city,name,age)   
(city, name):   
    
1. 从索引(city,name)找到第一个满足`city='杭州'`条件的主键id；   
1. 到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；   
1. 从索引(city,name)取下一个记录主键id；   
1. 重复步骤2、3，直到查到第1000条记录，或者是不满足`city='杭州'`条件时循环结束。   

(city,name,age)：   
    
1. 从索引(city,name,age)找到第一个满足`city='杭州'`条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；
1. 从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；
1. 重复执行步骤2，直到查到第1000条记录，或者是不满足`city='杭州'`条件时循环结束。
    
    [参考MySQL实战45讲/16讲]()

* 不走索引的情况   

对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。   
条件字段函数操作   
隐式类型转换   
隐式字符编码转换   
    [MySQL实战45讲/19]()

* 查询结果只有一条仍然满的几种情况
等MDL锁   
等flush（flush tables操作，关闭对应的表，确保数据刷新至磁盘）     
等行锁   
回滚至一致性读的概念，一致性读时若该数据被其他线程操作了很多次，需要回滚至当前事务开始时期   