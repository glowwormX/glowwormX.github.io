---
layout: post
title:  操作系统
date:   2019-01-26 08:00:00 +0800
categories: 基础
tag: 操作系统
---

* content
{:toc}

## 概念 缩写
GDT 操作系统的内存映射表
全局描述表(GDT Global Descriptor Table):在保护模式下一个重要的数据结构。
GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。
LDT(Local Descriptor Table) 进程的内存映射表，GDT表是操作系统的段表
GDT表是操作系统的段表，LDT每个进程的段表

cs查  gtd 查  内核段

PCB process control block
TCB  thread control block


在CPU中，CS的全拼为“Code Segment”，翻译为“代码段寄存器”，对应于内存中的存放代码的内存区域，用来存放内存代码段区域的入口地址（段基址）。
在CPU执行指令时，通过代码段寄存器（CS，Code Segment）和指令指针寄存器（IP，Instruction Pointer）来确定要执行的下一条指令的内存地址。
在CPU中类似的寄存器有：
DS：是 Data Segment 的缩写，翻译为“数据段寄存器”；
　　SS：是 Stack Segment 的缩写，翻译为“堆栈段寄存器”；
　　ES：是 Extra Segment 的缩写，翻译为“附加段寄存器”。


PC(Program Counter,PC)用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路，且具有自加1的功能，即可形成下一条指令的地址。
程序计数器是用于存放下一条指令所在单元的地址的地方。
为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。PC的维数一般和存储器地址寄存器MAR的维数一样。
当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）。

## 进程线程

## cpu管理 调度策略



## 内存管理
分段：根据程序分成程序段 数据段等放在不同物理内存上
分页：内存每一页4k一个单位，将程序分配再多个4k上
分段+分页将程序分段，映射在虚拟内存上（程序员角度），虚拟内存再映射实际内存页上（操作系统角度）   
问题：   
每一页4k，4G/4k=2^20，页表太大-->多级页表（虚拟再虚拟）但是查询时间变慢-->快表 放在cpu内部寄存器，保存最近经常访问的页表   

32位操作系统 虚拟内存都是4g，然而实际内存可以小于4G，使用换入换出来实现1G内存看似有4G内存
每个进程都有4GB的虚拟地址空间   
这4GB分3部分    
（1）一部分映射物理内存   
（2）一部分映射硬盘上的交换文件   
（3）一部分什么也不做   

[虚拟地址、逻辑地址、线性地址、物理地址](https://blog.csdn.net/rabbit_in_android/article/details/49976101)   




## 文件系统
磁盘基本概念 cyl柱面，head磁头(磁道)，sec扇区

![](/styles/images/java/disk1.jpeg)
![](/styles/images/java/disk2.jpeg)

获取三个值，如第2个柱面，第3个磁道，第4个扇区，就可以开始读数据了

三个参数太多，引入盘块号，（一层抽象），将三维信息编址到一维信息

磁盘访问时间 = 写入控制器时间 + 寻道时间 + 旋转时间 + 传输时间   
写入控制器时间：系统总线给磁盘发起命令的时间   
寻道时间 + 旋转时间：移动磁头的时间，旋转柱面，这个时间最长   
传输时间：读到后给系统总线

第二层抽象：通过队列访问磁盘，由磁盘驱动调度（电梯算法，从一端到另一端，圆形循环）
![](/styles/images/java/disk3.png)

第三层抽象：文件系统






2.1磁盘的构造

磁盘是一个扁平的圆盘(与电唱机的唱片类似)。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图11.3中所示的6片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。



 

当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了。

一般磁盘分为固定头盘(磁头固定)和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。

活动头盘 (如上图)的磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。 

2.2磁盘的读/写原理和效率

磁盘上数据必须用一个三维地址唯一标示：柱面号、磁道、块号(磁道上的盘块)。

读/写磁盘上某一指定数据需要下面3个步骤：

(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。

(2)  如上图11.3中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。

(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。

经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。

访问某一具体信息，由3部分时间组成：

● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。

● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。

● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s

磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。

所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。



[操作系统相关](https://www.cnblogs.com/ranjiewen/category/789808.html)   
